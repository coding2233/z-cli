#include <cstdlib>
#include <string>
#include <vector>

#include "cli_app.h"
#include "core/cli_core.h"
#include "excel/excel_cli.h"
#include "fanyi/fanyi_cli.h"
#include "spdlog/spdlog.h"
#include "update/update_cli.h"
#include "json/json_cli.h"


#include "utf8_console.h"

CliApp::CliApp()
{
   
}

CliApp::~CliApp(){}


#include "cxxopts.hpp"

int CliApp::Run(int argc,char* args[])
{
    //控制台支持utf-8
    initialize_utf8_console();
    //初始化
    Init(args[0]);

    cxxopts::Options options("z-cli", "A command line tool for z.");
    options.add_options()
        ("h,help", "Print help")
        ("command", "The command to execute", cxxopts::value<std::string>())
        ("args", "Arguments for the command", cxxopts::value<std::vector<std::string>>());

    options.parse_positional({"command", "args"});

    auto result = options.parse(argc, args);

    if (result.count("help"))
    {
        std::cout << options.help() << std::endl;
        std::cout << "\nAvailable commands:\n";
        for (const auto& pair : clis_)
        {
            std::cout << "  " << pair.first << " - " << pair.second->GetHelpText() << "\n";
        }
        std::cout << "\nUse 'z-cli <command> --help' for more information about a command.\n";
        return 0;
    }

    if (result.count("command"))
    {
        std::string command = result["command"].as<std::string>();
        auto it = clis_.find(command);
        if (it != clis_.end())
        {
            auto& cli = it->second;
            cli->SetupOptions();
            auto& cli_options = cli->GetOptions();
            cli_options.parse_positional({"args"});
            auto cli_result = cli_options.parse(argc, args);
            return cli->Run(cli_result);
        }
        else
        {
            std::cout << "Unknown command: " << command << std::endl;
            return 1;
        }
    }
    else
    {
        // Interactive mode
        std::string read_line;
        while (true)
        {
            std::cout << "z-cli> ";
            std::getline(std::cin, read_line);
            if (read_line == "exit")
            {
                break;
            }
            // This part needs to be refactored to handle interactive commands
            // For now, it's disabled.
        }
    }

    return 0;
}


void CliApp::Init(std::string app_path)
{
    SPDLOG_INFO("Init app_path: {}",app_path);
    app_path = GetAppPath(app_path);
    SPDLOG_INFO("app_path: {}",app_path);
    // 获取当前程序的完整路径  
    std::filesystem::path executable_path = std::filesystem::canonical(app_path);  
    // 获取程序所在的目录  
    std::string app_directory = executable_path.parent_path().string();  
    SPDLOG_INFO("app_directory: {}",app_directory);
    CliCore::GetCliCore().SetAppPath(app_directory);
    // 创建本地文件系统，指向程序所在目录  
    auto app_fs = std::make_unique<NativeFileSystem>(app_directory);  
    app_fs->Initialize();  
    //挂载App路径
    auto vfs =  CliCore::GetCliCore().GetVirtualFileSystem();
    vfs->AddFileSystem("/app", std::move(app_fs));

    //添加更多的执行
    AddClis();

    //https://appworlds.cn/translate
    // std::string url = std::string("https://translate.appworlds.cn/?text=This%20is%20a%20test%20text&from=en&to=zh-CN");
    // // std::string url = std::string("https://translate.appworlds.cn?text=This is a test text&from=en&to=zh-CN");
    // std::string response;
    // int ret = CliCore::GetCliCore().Get(url,response);
    // SPDLOG_INFO("url->{} {}",ret,response);
}




// This function is now automatically generated by a script.
// See scripts/gen_add_clis.lua

std::string CliApp::GetAppPath(std::string app_path)
{
    #ifdef _WIN32
    if (app_path.find("\\")==std::string::npos)
    {
        std::string env_path = std::string(getenv("PATH"));
        // SPDLOG_INFO("env_path: {}",env_path);
        int start_index= 0 ;
        int find_index = 0;
        for (size_t i = 0; i < env_path.size(); i++)
        {
            if (';'== env_path[i])
            {
                find_index = i;
                // SPDLOG_INFO("start_index:{} find_index:{} length:{} env_size:{}",start_index,find_index,find_index-start_index,env_path.size());
                std::string find_app_path = env_path.substr(start_index,find_index-start_index)+"\\"+app_path+".exe";
                // SPDLOG_INFO("find_app_path: {}",find_app_path);
                if (std::filesystem::exists(find_app_path))
                {
                    app_path = find_app_path;
                    break;
                }
                else
                {
                    start_index = find_index+1;
                }
            }
        }
    }
    #else
    if (app_path.find("/")==std::string::npos)
    {
        std::string env_path = std::string(getenv("PATH"));
        // SPDLOG_INFO("env_path: {}",env_path);
        int start_index= 0 ;
        int find_index = 0;
        for (size_t i = 0; i < env_path.size(); i++)
        {
            if (':'== env_path[i])
            {
                find_index = i;
                // SPDLOG_INFO("start_index:{} find_index:{} length:{} env_size:{}",start_index,find_index,find_index-start_index,env_path.size());
                std::string find_app_path = env_path.substr(start_index,find_index-start_index)+"/"+app_path;
                // SPDLOG_INFO("find_app_path: {}",find_app_path);
                if (std::filesystem::exists(find_app_path))
                {
                    app_path = find_app_path;
                    break;
                }
                else
                {
                    start_index = find_index+1;
                }
            }
        }
    }
    #endif
    return app_path;
}
